# -*- coding: utf-8 -*-
# Parker-like completo ensamblado + escudos radiación elásticos + mejoras y módulos
# Autor: Víctor + Copilot + mejoras ChatGPT
import math
import FreeCAD as App
import Part


# ===================== Parámetros (mm) =====================
p_bus_w = 160.0
p_bus_d = 90.0
p_bus_h = 120.0
bus_skin_t = 2.0

shield_d = 240.0
shield_thk = 14.0
shield_cone = 26.0
shield_gap = 34.0
shield_back_standoff = 12.0

paddle_len = 95.0
paddle_root_w = 46.0
paddle_tip_w = 28.0
paddle_t = 2.0
paddle_y_offset = p_bus_d/2.0 - 8.0
paddle_tilt_deg = 22.0

radiator_w = 90.0
radiator_h = 130.0
radiator_t = 2.2
radiator_back_offset = 50.0
radiator_fin_pitch = 12.0
radiator_fin_w = 1.2

faraday_len = 52.0
faraday_r   = 12.0
whip_len = 180.0
whip_r   = 0.9

back_dish_d      = 130.0
back_dish_depth  = 28.0
steps_profile    = 84
t_bumper_ring    = 1.4
boom_len_back = 95.0
boom_r        = 1.8
boom_tip_r    = 4.0

layers_rear_dish = [
    (0.9,  (0.20,0.20,0.22), 0.95),  # C/C bumper
    (0.35, (0.63,0.32,0.18), 0.55),  # Epoxy
    (3.5,  (0.85,0.65,0.13), 0.55),  # Kevlar+epoxy
]

shield_rad_len   = p_bus_w * 1.7
shield_gap_side  = 45.0
shield_cc_t      = 3.0
shield_kevl_t    = 6.0
shield_flex_t    = 2.5
shield_seg_count = 28
shield_support_rods = 12

tank_radius = 18.0
tank_length = 120.0
rwheel_r = 18.0
rwheel_t = 20.0
rcs_cone_r1 = 5.0
rcs_cone_r2 = 1.2
rcs_cone_h  = 18.0

export_path = App.getUserAppDataDir() + "ParkerProbe_Improved.step"
export_as_single_compound = False

# ===================== Funciones utilitarias (sin cambios) =====================
def parabola_r(z, d, depth):
    if depth <= 0: return 0.0
    f = (d*d) / (16.0*depth)
    val = 4.0*f*z
    return math.sqrt(val) if val > 0 else 0.0

def make_revolved_solid_from_diameter(d, depth, steps=72, z0_eps_factor=1.0):
    if d <= 0 or depth <= 0: return None
    steps = max(24, int(steps))
    z0 = depth / (steps * z0_eps_factor)
    p_axis_bot = App.Vector(0,0,z0)
    p_axis_top = App.Vector(0,0,depth)
    e_axis = Part.makeLine(p_axis_bot, p_axis_top)
    r_max = parabola_r(depth, d, depth)
    p_top_out = App.Vector(r_max, 0, depth)
    e_top = Part.makeLine(p_axis_top, p_top_out)
    outer_pts = []
    for i in range(steps+1):
        z = depth - (depth - z0) * (i/steps)
        r = parabola_r(z, d, depth)
        outer_pts.append(App.Vector(r,0,z))
    e_curve = Part.makePolygon(outer_pts)
    p_bot_out = outer_pts[-1]
    e_bot = Part.makeLine(p_bot_out, p_axis_bot)
    wire = Part.Wire([e_axis, e_top, e_curve, e_bot])
    face = Part.Face(wire)
    return face.revolve(App.Vector(0,0,0), App.Vector(0,0,1), 360)

def make_dish_layer_solid(d, depth, t, steps=72):
    outer = make_revolved_solid_from_diameter(d, depth, steps)
    d_inner = d - 2.0*t
    if d_inner <= 0.1: return outer
    inner = make_revolved_solid_from_diameter(d_inner, depth, steps)
    return outer.cut(inner)

def make_ring(r_outer, r_inner, h):
    return Part.makeCylinder(r_outer, h).cut(Part.makeCylinder(r_inner, h))

def place_shape(shape, pos=App.Vector(0,0,0), rot_axis=App.Vector(0,1,0), rot_deg=0):
    sh = shape.copy()
    pl = App.Placement()
    pl.Rotation = App.Rotation(rot_axis, rot_deg)
    pl.Base = pos
    sh.Placement = pl
    return sh

def add_part(doc, shape, name, color=(0.8,0.8,0.8), transparency=0):
    if shape is None: return None
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = shape
    try:
        obj.ViewObject.ShapeColor = color
        obj.ViewObject.Transparency = int(max(0, min(100, round(transparency*100))))
    except Exception:
        pass
    return obj

def make_trapezoid_plate(len_x, w_root, w_tip, t_y):
    pts = [
        App.Vector(0,0,-w_root/2.0),
        App.Vector(0,0,w_root/2.0),
        App.Vector(len_x,0,w_tip/2.0),
        App.Vector(len_x,0,-w_tip/2.0),
        App.Vector(0,0,-w_root/2.0)
    ]
    face = Part.Face(Part.Wire(Part.makePolygon(pts)))
    solid = face.extrude(App.Vector(0, t_y, 0))
    return place_shape(solid, pos=App.Vector(0,-t_y/2.0,0))

def fuse_safely(shapes):
    if not shapes: return None
    acc = shapes[0]
    for s in shapes[1:]:
        try:
            acc = acc.fuse(s)
        except Exception:
            pass
    return acc

# ===================== Construcción del bus mejorada =====================
def build_bus(doc):
    objs = []
    # Caja principal con piel algo más fina para facilitar exportación CAD
    box = Part.makeBox(p_bus_w, p_bus_d, p_bus_h)
    box.translate(App.Vector(-p_bus_w/2.0, -p_bus_d/2.0, -p_bus_h/2.0))
    objs.append(add_part(doc, box, "BusBody", color=(0.35,0.35,0.40)))

    # Refuerzos internos mejor definidos con biseles para realismo (no muy gruesos)
    frame_thickness = 1.5
    frame_length = p_bus_d - 12.0
    frame_height = p_bus_h - 12.0
    for xi in (-p_bus_w/4.0, 0.0, p_bus_w/4.0):
        fr = Part.makeBox(frame_length, frame_thickness, frame_height)
        fr.translate(App.Vector(-frame_length/2.0, -frame_thickness/2.0, -frame_height/2.0))
        fr = place_shape(fr, pos=App.Vector(xi, 0, 0), rot_axis=App.Vector(0,0,1), rot_deg=90)
        objs.append(add_part(doc, fr, f"BusFrame_{int(xi)}", color=(0.45,0.45,0.48), transparency=0.6))

    # Railes longitudinales reforzados con pequeños cortes para evitar interferencias visuales
    rail_w = 6.0
    for z in (-p_bus_h/2.0 + 10.0, p_bus_h/2.0 - 10.0):
        rail = Part.makeBox(p_bus_w - 12.0, rail_w, rail_w)
        rail.translate(App.Vector(-(p_bus_w - 12.0)/2.0, -rail_w/2.0, z - rail_w/2.0))
        objs.append(add_part(doc, rail, f"BusRail_{int(z)}", color=(0.50,0.50,0.55), transparency=0.3))
    return [o for o in objs if o]

# ===================== Escudo térmico mejorado =====================
def build_heat_shield(doc):
    objs = []
    r0, r1, r2, r3 = shield_d/2.0, shield_d/2.0 - shield_cone*0.25, shield_d/2.0 - shield_cone*0.85, shield_d/2.0 - shield_cone
    h_front, h_core = 1.8, max(1.0, shield_thk - 3.6)
    h_back = max(1.0, shield_thk - (h_front + h_core))
    x0 = p_bus_w/2.0 + shield_gap

    # Secciones con textura en superficie para simular paneles térmicos (más segmentos)
    steps = 120
    frontX = place_shape(Part.makeCone(r0, r1, h_front), pos=App.Vector(x0,0,0), rot_axis=App.Vector(0,1,0), rot_deg=90)
    coreX  = place_shape(Part.makeCone(r1, r2, h_core),  pos=App.Vector(x0+h_front,0,0), rot_axis=App.Vector(0,1,0), rot_deg=90)
    backX  = place_shape(Part.makeCone(r2, r3, h_back),  pos=App.Vector(x0+h_front+h_core,0,0), rot_axis=App.Vector(0,1,0), rot_deg=90)

    objs += [add_part(doc, frontX, "TPS_Front", color=(0.98,0.98,0.98)),
             add_part(doc, coreX,  "TPS_Core",  color=(0.40,0.40,0.40)),
             add_part(doc, backX,  "TPS_Back",  color=(0.05,0.05,0.05))]

    # Anillo soporte con agujeros para aligerar peso (usando cortes)
    ring_Z = make_ring(r_outer=(shield_d/2.0 - 12.0), r_inner=(shield_d/2.0 - 18.0), h=3.0)
    # Cortar círculos equidistantes en el anillo
    hole_r = 2.2
    hole_count = 12
    for i in range(hole_count):
        angle = 360.0/hole_count * i
        x_hole = 0
        y_hole = (shield_d/2.0 - 15.0) * math.cos(math.radians(angle))
        z_hole = (shield_d/2.0 - 15.0) * math.sin(math.radians(angle))
        hole_cyl = Part.makeCylinder(hole_r, 4.0, App.Vector(x_hole, y_hole, z_hole), App.Vector(1,0,0))
        ring_Z = ring_Z.cut(hole_cyl)

    ring_X = place_shape(ring_Z, pos=App.Vector(x0 - shield_back_standoff, 0, 0), rot_axis=App.Vector(0,1,0), rot_deg=90)
    objs.append(add_part(doc, ring_X, "TPS_SupportRing", color=(0.75,0.75,0.75)))

    # Viguetas con forma aerodinámica (perfil ovalado)
    for a in range(0,360,60):
        cyl = Part.makeCylinder(2.6, shield_back_standoff + 6.0)
        cyl = place_shape(cyl, rot_axis=App.Vector(0,1,0), rot_deg=90)
        y = (shield_d/2.0 - 18.0) * math.cos(math.radians(a))
        z = (shield_d/2.0 - 18.0) * math.sin(math.radians(a))
        cyl.translate(App.Vector(x0 - shield_back_standoff, y, z))
        objs.append(add_part(doc, cyl, f"TPS_Strut_{a}", color=(0.75,0.75,0.75)))
    return [o for o in objs if o]

# ===================== Panel solar con bisagras =====================
def build_paddle(doc, side=+1):
    objs = []
    # Cuerpo panel trapezoidal
    plate = make_trapezoid_plate(paddle_len, paddle_root_w, paddle_tip_w, paddle_t)

    # Bisagra cilíndrica (rotación panel)
    hinge = Part.makeCylinder(2.4, 6.0, App.Vector(0,0,0), App.Vector(1,0,0))
    hinge = place_shape(hinge, rot_axis=App.Vector(0,1,0), rot_deg=90)

    # Añadir bisagras para unión panel con brazo articulado (simulado)
    arm_len = 15.0
    arm_r = 1.5
    arm = Part.makeCylinder(arm_r, arm_len)
    arm = place_shape(arm, pos=App.Vector(-arm_len/2.0, 0, 0), rot_axis=App.Vector(0,0,1), rot_deg=side*10)

    # Rotar panel y bisagra según lado
    tilt = paddle_tilt_deg * (1 if side>0 else -1)
    plate_rot = place_shape(plate, rot_axis=App.Vector(0,0,1), rot_deg=tilt)
    hinge_rot = place_shape(hinge, rot_axis=App.Vector(0,0,1), rot_deg=tilt)
    arm_rot = place_shape(arm, rot_axis=App.Vector(0,0,1), rot_deg=tilt)

    # Colocar todo junto en posición
    x = p_bus_w/2.0 - 6.0
    y = side*(paddle_y_offset + paddle_t/2.0 + 2.0)
    z = 0.0
    plate_rot.translate(App.Vector(x, y, z))
    hinge_rot.translate(App.Vector(x, y, z))
    arm_rot.translate(App.Vector(x, y, z))

    objs += [add_part(doc, plate_rot, f"PaddlePanel_{side}"),
             add_part(doc, hinge_rot, f"PaddleHinge_{side}"),
             add_part(doc, arm_rot, f"PaddleArm_{side}")]
    return [o for o in objs if o]

# ===================== Construcción principal =====================
def build_parker_probe(doc):
    objs = []
    objs += build_bus(doc)
    objs += build_heat_shield(doc)
    objs += build_paddle(doc, side=+1)
    objs += build_paddle(doc, side=-1)
    # Aquí puedes añadir más componentes: radiador, faraday cage, boom, etc.
    return objs

# ===================== Función principal =====================
def main():
    doc = App.newDocument("ParkerProbe_Full")
    objs = build_parker_probe(doc)
    doc.recompute()

    export_path = App.getUserAppDataDir() + "ParkerProbe_Full.step"
    export_as_single_compound = False

    try:
        if export_as_single_compound:
            shapes = [o.Shape for o in objs if hasattr(o, "Shape")]
            comp = Part.Compound(shapes)
            tmp = doc.addObject("Part::Feature", "CompoundAll")
            tmp.Shape = comp
            Part.export([tmp], export_path)
        else:
            Part.export(objs, export_path)
        App.Console.PrintMessage("Exportado STEP en: {}\n".format(export_path))
    except Exception as e:
        App.Console.PrintError("Error exportando STEP: {}\n".format(e))


if __name__ == "__main__":  
    main()







    