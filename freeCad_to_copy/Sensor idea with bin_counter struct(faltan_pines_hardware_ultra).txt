//Sensor idea with bin_counter structure-signals -450
//Pin planner videos/waveform configuraciones/Questa videos/configuraciones

-- entity
entity bin_counter is
-- options
generic(N: integer :=8);
-- port declaration
port(
   _, _: in std_logic;
   _,_,_: in std_logic;
   _: in std_logic_vector(N-1 downto 0); -- input data pin
_: out std_logic; -- output status
_: out std_logic_vector(N-1 downto 0) -- output data
);
end bin counter;

-- architecture body
architecture demo_arch of bin_counter is
-- constant declaration
constant MAX: integer := (2**N-1);
-- internal signal declaration
signal r_reg: unsigned(N-1 downto 0);
signal r_next: unsigned(N-1 downto 0);
begin
-- component hardware-sensor1/
//sensor of temperatura
//sensor of medical equipment signals example- copilot genera ideas con mis ejemplos, detección de cancer y de la resistencia a las temperaturas por calor y por frio de una turbina-acelerómetro/motor del turbo fan y modulo o entity para detección de tumor maligno en una maquina medica. Con los contadores como
estructura para el procesador PS o RISCV e ideas de contadores-Led o simplemente counter para sensor de temperatura y sensor magnético o de infrarojos en hospitales con ALTERA o Xilinx a nivel de procesos procesamiento de señales verilog/vhdl

-- component
-- memory elements
-- register
process(_,_)
begin
   if (_='1') then
      r_reg <= (others=>'0');
   elsif (_'event and _='1') then
      r_reg <= r_next;
   end if;
end process;

-- combinational circuits detection
-- temperatura
-- tumor/cancer
-- señales para detectar un tumor maligno con Xilinx o con altera

-- register, prototipo de registro, sustituir puertos por o bien ZCU106, kintex KCU116 o CycloneIV
process(_,_)
begin
   if (_='1') then
      r_reg <= (others=>'0');
   elsif (_'event and _='1') then
      r_reg <= r_next;
   end if;
end process;

-- next state logic 451
r_next <= (others=>'0') when syn_clr='1' else
          unsigned(d)   when load='1' else
          r_reg + 1     when en = '1' else
r_reg;
-- output logic
q <= std_logic_vector(r_reg);
max_tick <= '1' when r_reg=MAX else '0'; //chatGPT/copilot r_reg=MAX no lo pillo
end demo_arch;

//counter_inst
library ieee;
use ieee.std_logic_1164.all;
entity counter_inst is
   port(
      _,_: in std_logic;
      _,_,_: in std_logic;
      _: in std_logic_vector(15 downto 0);
      _,_: out std_logic;
      _: out std_logic_vector(15 downto 0);
end counter_inst;

architecture structure_arch of counter_inst is begin
-- 16-bit counter, all ports used
counter_16_unit: entity work.bin_counter(demo_arch)
generic map(N=>16)
//Pines o puertos físicos del constraints xdc de vivado que voy a pasarte a ti copilot para que puedas rellenar los huecos correctamente.
port map(_=>_, _=>_,_=>_,_=>_,_=>_,_=>_,_=>_,_=>_);
-- free-running 8-bit counter
-- with only max_tick signal
counter_8_unit: entity work.bin_counter
   port map(_=>_, _=>_, _=>'0',_=>_'1', _=>'0',_=>"00000000", _=>_, _=>open);
end structure_arch;

-- COMBINATIONAL CIRCUITS LOGIC
-- Arithmetic operations
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity arith_demo is
   port(
      a, b: in std_logic_vector(7 downto 0);
      diff, inc: out std_logic_vector(7 downto 0)
);
end arith_demo;

architecture arch of arith_demo is
  signal au, bu, diffu: unsigned(7 downto 0);
begin
-- convert inputs to unsigned/signed internally -- and then convert the result back

au <= unsigned();
bu <= unsigned();
diffu <= au - bu when (au > bu) else
         bu - au;
diff <= std_logic_vector(diffu);
-- convert multiple times in a statement 
inc <= std-logic-vector(unsigned(a) + 1); 
end arch; 

-- Fixed-amount shift operations
library ieee; 
use ieee. std-logic-1164, all ; 
entity dixed_shift_demo is
   port(
      _: in std_logic_vector(7 downto 0);
      _, _, _, _, _: out
         std_logic_vector(7 downto 0)
);
end fixed_shift_demo;

architecture arch of fixed_shift_demo is
begin
-- shift left 3 positions
_ <= _(4 downto 0) & "000" ;
_ <= "000" & _(7 downto 3);
-- shift right 3 positions and shifting in sign bit
-- arithmetic shift
_ <= _(7) & _(7) & _(7)& _(7 downto 3);
--rotate right 3 positions
rot <= _(2 downto 0) & a(7 downto 3);
-- rotate right 3 positions
rot1 <= _(2 downto 0) & a(7 downto 3);
-- swap two nibbles
_<= _(3 downto 0) & _(7 downto 4);
end arch;



